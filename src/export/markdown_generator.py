"""
Markdown file generation and management for ScribeVault summaries.
"""

import os
from pathlib import Path
from datetime import datetime
from typing import Optional, Dict, Any
import logging

logger = logging.getLogger(__name__)

class MarkdownException(Exception):
    """Custom exception for markdown generation errors."""
    pass

class MarkdownGenerator:
    """Handles generation and storage of markdown summary files."""
    
    def __init__(self, export_dir: str = "summaries"):
        """Initialize the markdown generator."""
        self.export_dir = Path(export_dir)
        self.export_dir.mkdir(exist_ok=True)
        
        # Create subdirectories for organization
        self.daily_dir = self.export_dir / "daily"
        self.by_category_dir = self.export_dir / "by-category"
        
        self.daily_dir.mkdir(exist_ok=True)
        self.by_category_dir.mkdir(exist_ok=True)
        
    def save_markdown_file(self, recording_data: Dict[str, Any], template_prompt: Optional[str] = None) -> Path:
        """Generate and save markdown file for a recording."""
        try:
            # Extract data with safe defaults
            title = recording_data.get('title') or recording_data.get('filename', 'Untitled Recording')
            created_at = recording_data.get('created_at', datetime.now().isoformat())
            category = recording_data.get('category', 'other')
            duration = recording_data.get('duration', 0)
            summary = recording_data.get('summary', 'No summary available')
            transcription = recording_data.get('transcription', 'No transcription available')
            
            # Parse datetime for formatting
            try:
                if isinstance(created_at, str):
                    dt = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
                else:
                    dt = created_at
            except:
                dt = datetime.now()
            
            # Format duration
            duration_str = self._format_duration(duration)
            date_str = dt.strftime("%Y-%m-%d %H:%M:%S")
            
            # Category emoji mapping
            category_emoji = {
                'meeting': '🤝',
                'interview': '🎤',
                'lecture': '🎓',
                'note': '📝',
                'call': '📞',
                'presentation': '📊',
                'other': '📄'
            }
            
            emoji = category_emoji.get(category, '📄')
            
            # Professional markdown template
            markdown_content = f"""# {emoji} {title}

**Date**: {date_str}  
**Category**: {category.title()}  
**Duration**: {duration_str}  
**Generated**: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

---

## 📋 Professional Summary

{summary}

---

## 📝 Complete Transcription

```
{transcription}
```

---

## 📊 Meeting Metadata

- **Recording ID**: {dt.isoformat()}
- **Category**: {category}
- **Duration**: {duration_str}
- **Export Date**: {datetime.now().isoformat()}

---

*Generated by ScribeVault - Professional Meeting Analysis & Transcription*
"""
            
            # Create filename
            safe_title = "".join(c for c in title if c.isalnum() or c in (' ', '-', '_')).strip()
            safe_title = safe_title.replace(' ', '_')[:50]
            timestamp = dt.strftime("%Y%m%d_%H%M%S")
            filename = f"{timestamp}_{safe_title}.md"
            
            # Save file
            primary_path = self.export_dir / filename
            primary_path.write_text(markdown_content, encoding='utf-8')
            
            logger.info(f"Markdown file saved: {primary_path}")
            return primary_path
            
        except Exception as e:
            logger.error(f"Failed to save markdown file: {e}")
            raise MarkdownException(f"Markdown save failed: {e}")
    
    def _format_duration(self, duration: float) -> str:
        """Format duration in seconds to human-readable format."""
        if duration <= 0:
            return "Unknown"
        
        hours = int(duration // 3600)
        minutes = int((duration % 3600) // 60)
        seconds = int(duration % 60)
        
        if hours > 0:
            return f"{hours}h {minutes}m {seconds}s"
        elif minutes > 0:
            return f"{minutes}m {seconds}s"
        else:
            return f"{seconds}s"
